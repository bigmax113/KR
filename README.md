# AI-рецепты в мобильном приложении для кухонного комбайна (Grok/xAI)
## Чёткое разделение задач: Backend vs Mobile (Android/iOS)

---

# 0) Общая цель и принцип разделения ответственности

**Цель:**  
- 350 рецептов (RU) показываются пользователю на **системном языке**.  
- Для рецептов “не из списка” пользователь запрашивает AI: сервис **находит рецепт в сети**, **извлекает**, **нормализует**, **адаптирует под режимы комбайна**, **проверяет ограничения**, **локализует** и отдаёт в приложение.

**Критически важно:**  
- Любая работа с xAI/Grok (ключи, web_search, кэш, валидация) — **только на backend**.  
- Mobile — **только UI/UX + вызовы backend + отображение результата**.

---

# 1) Контракт между Mobile и Backend (единая “граница”)

## 1.1 Формат данных
Backend возвращает **структуру**, а не “только текст”. Минимальный набор:
- `canonical_recipe` (структурные данные)
- `localized` (локализованные строки под `lang`)
- `robot_program[]` (параметризованные режимы устройства)
- `manual_steps[]` (шаги пользователя руками)
- `warnings[]` (безопасность/ограничения)
- `questions[]` (уточнения, если данных не хватает)
- `source_urls[]` (для рецептов из сети)

## 1.2 Типовой ответ backend
```json
{
  "recipe_id": "uuid",
  "lang": "uk",
  "origin": "internal|web",
  "canonical_recipe": { "...": "..." },
  "localized": {
    "title": "…",
    "ingredients": ["…"],
    "steps": ["…"]
  },
  "robot_program": [
    { "mode": "CHOP", "speed": 6, "duration_sec": 20, "attachment": "knife" }
  ],
  "manual_steps": [
    "Установите нож.",
    "Добавьте лук."
  ],
  "warnings": [
    "Не превышайте max_fill 2000 мл."
  ],
  "questions": [
    { "id": "servings", "type": "number", "text": "На сколько порций готовим?" }
  ],
  "source_urls": [
    "https://example.com/recipe"
  ]
}
```

---

# 2) BACKEND (что делает серверная команда)

## 2.1 Роль backend
Backend — это **AI Orchestrator** + **Recipe Service**:
- Хранение рецептов (канон).
- Локализация (перевод RU → lang) + кэш.
- “Generate from web”: поиск → извлечение → нормализация → адаптация под Robot Profile → валидация → локализация.
- Безопасность: ключи, лимиты, фильтры источников, аудит/логи.
- Версионирование схем и промптов.

## 2.2 Хранилища и данные
### 2.2.1 Canonical Recipe DB (обязательное)
Хранить рецепт как **структуру**:
- ingredients[] (qty + unit в нормализованных единицах)
- steps[] (атомарные действия)
- tags, times, servings
- `version`

### 2.2.2 Robot Profile (обязательное)
Описание конкретного комбайна (и/или линейки) в JSON:
- режимы и диапазоны (speed/temp/duration)
- насадки/аксессуары
- ограничения чаши (объём/масса/макс. заполнение)
- “идиомы” режима (например SAUTE = HEAT+stir)

### 2.2.3 Translation Cache (рекомендуется)
Ключ: `(recipe_id, lang, recipe_version)`  
Чтобы не переводить один и тот же рецепт заново.

### 2.2.4 Web Recipe Cache (рекомендуется)
Ключ: `(normalized_query, robot_model, lang, constraints_hash)` с TTL.

## 2.3 Эндпоинты backend (минимальный набор)

### 2.3.1 Получить рецепт из базы (уже локализованный)
`GET /v1/recipes/{id}?lang=xx`

Backend:
- достаёт canonical
- при необходимости локализует (или берёт из кэша)
- отдаёт структуру + локализованные строки

### 2.3.2 Сгенерировать рецепт из сети (полный pipeline)
`POST /v1/recipes/generate`

Вход:
```json
{
  "query": "том-ям",
  "lang": "uk",
  "robot_model": "AENO_XYZ",
  "constraints": {
    "servings": 2,
    "diet": ["no_pork"]
  }
}
```

Backend pipeline:
1) Web search (tool) → 2–3 источника
2) Extract → canonical JSON
3) Normalize units (g/ml/pcs)
4) Adapt → `robot_program[]` + `manual_steps[]`
5) Validate (Robot Profile) → warnings/errors
6) Localize → `lang`
7) Return result (+ сохранить как user_generated, если нужно)

### 2.3.3 Уточнение/диалог (если backend задаёт вопросы)
`POST /v1/recipes/generate/continue`

Вход:
```json
{
  "session_id": "uuid",
  "answers": { "servings": 4, "has_whisk": true }
}
```

Backend:
- продолжает адаптацию/валидацию/локализацию
- возвращает финальный результат

### 2.3.4 Телеметрия и фидбек качества
`POST /v1/feedback`
- рейтинг, “ошибка”, “слишком долго”, “не сходятся граммы”, “не тот режим”, и т.п.

## 2.4 Валидация (обязательный слой)
Backend обязан проверять:
- speed/temp/duration в диапазоне Robot Profile
- масса/объём не превышают ограничения
- корректные шаги “сменить насадку”
- наличие аксессуаров (если отсутствуют — questions/cannot_map)
- безопасность (предупреждения, аллергены, сырые продукты)

## 2.5 Mapping Rules (детерминированный слой)
Backend хранит таблицу соответствий:
- “измельчить” → CHOP
- “взбить” → WHISK
- “замесить” → KNEAD
- “варить/тушить” → HEAT + stir_speed
- “на пару” → STEAM (если есть корзина)

LLM получает mapping как вход и **не имеет права** выходить за Robot Profile.

## 2.6 Безопасность и эксплуатация (backend-only)
- Хранение xAI API key в secrets vault / env.
- Rate limiting:
  - “generate from web” дороже → отдельные лимиты.
- Логи:
  - request_id, user_id (или device_id), модель, стоимость, источники, ошибки.
- Content policy:
  - allowed/excluded domains (качество и риск).
- Версионирование:
  - schema_version для recipe и prompt_version для AI.

## 2.7 Технические примечания по xAI/Grok (backend-only)
Держать в конфиге:
- base URL (пример в код-блоке):
```text
https://api.x.ai
```
- использовать Responses API (как единый клиентский слой)
- использовать tool web_search для поиска рецептов из сети

---

# 3) MOBILE (что делает команда Android/iOS)

## 3.1 Роль mobile
Mobile НЕ делает:
- web scraping / поиск в сети
- перевод через LLM
- адаптацию под Robot Profile
- валидацию режимов
- хранение ключей xAI

Mobile ДЕЛАЕТ:
- UI/UX: список рецептов, карточка рецепта, “приготовить”, “подобрать рецепт из сети”
- вызовы backend API
- локальное кеширование UI-данных (опционально)
- отображение предупреждений, уточняющих вопросов, источников
- интеграцию с “управлением устройством” (если есть): отправка `robot_program` в комбайн

## 3.2 Экранные сценарии (UX)

### 3.2.1 Каталог “встроенных” рецептов
- Получить список рецептов (метаданные) на `lang`:
  - title, preview image, tags, time, difficulty
- По клику — `GET /recipes/{id}?lang=xx`
- Показать:
  - ингредиенты, шаги, time/servings
  - “Программа комбайна” (если есть)
  - предупреждения (если есть)

### 3.2.2 “Рецепт не из списка” (AI)
- Поле ввода: название рецепта
- Выбор ограничений (опционально):
  - порции, диета, аллерген, “без духовки”, и т.п.
- Нажатие “Найти и адаптировать”
- Вызов `POST /recipes/generate`
- Отобразить состояние:
  - progress: “ищем источники → извлекаем → адаптируем → проверяем → переводим”
- Если пришли `questions[]`:
  - показать 1–2 коротких вопроса в UI
  - отправить `continue` с ответами
- Показать финальный рецепт + `source_urls` + warnings

### 3.2.3 “Запуск на комбайне”
Если приложение управляет комбайном:
- отображать `robot_program` в понятном виде:
  - режим, скорость, температура, длительность, насадка
- подтверждение пользователем перед запуском
- отправка `robot_program` по протоколу устройства (BLE/Wi‑Fi/Cloud) — **это mobile/IoT слой**, не AI.

## 3.3 Локализация на mobile
- UI строки (кнопки, меню, ошибки) — стандартная i18n (Android string resources / iOS Localizable.strings).
- Текст рецепта приходит **уже локализованный** с backend.
- Если в рецепте есть единицы/форматы:
  - mobile может форматировать отображение (например, “250 g” vs “250 г”), но **не менять смысл**.

## 3.4 Offline/кэш на mobile (опционально)
- Можно кэшировать последние N рецептов (локализованные), чтобы открывались без сети.
- “Generate from web” — по определению online.

## 3.5 Ошибки и их обработка (mobile)
Mobile должен корректно обрабатывать:
- 429 (rate limit) → показать “попробуйте позже”
- 5xx → “сервис временно недоступен”
- “not found sources” → “не удалось найти рецепт, уточните запрос”
- “cannot_map” → показать что не поддерживается данным комбайном и предложить альтернативы/ручные шаги

---

# 4) Что согласовать заранее (чтобы не было конфликтов “кто что делает”)

## 4.1 Backend предоставляет
- Каноническую схему рецепта
- Robot Profile и валидатор
- Локализацию/перевод и кэш
- “Generate from web” pipeline
- Единый API контракт + версии

## 4.2 Mobile реализует
- UI/UX и сценарии
- Обработку `questions[]` (уточнения) как диалог
- Отображение `warnings[]` и `source_urls[]`
- Интеграцию “запуска программы” на устройстве (если применимо)

---

# 5) Быстрый план запуска MVP (разделённый)

## Backend MVP (1–2 итерации)
1) Robot Profile JSON для конкретной модели
2) Canonical schema + конвертация 350 RU рецептов в структуру
3) `GET /recipes/{id}?lang=xx` + перевод (on-demand) + кэш
4) `POST /recipes/generate` (web_search → extract → adapt → validate → localize)
5) Лимиты, логи, доменные фильтры

## Mobile MVP (параллельно)
1) Каталог рецептов + карточка рецепта
2) Экран AI-запроса (название + кнопка) + экран прогресса
3) UI для уточняющих вопросов (questions[])
4) Отображение результата: шаги/ингредиенты/robot_program/warnings/sources
5) (опционально) “Запустить на комбайне” — если уже есть управление устройством

---

# 6) Мини-чеклист входных данных от продуктовой команды
- Robot Profile: режимы, диапазоны, насадки, ограничения чаши
- Список целевых языков + приоритет предперевода
- Политика по web-рецептам: показываем источники? сохраняем? какие домены разрешаем?
- Тон/формат выдачи: короткие шаги vs подробные, единицы измерения, предупреждения
